%-------------------------------------------------------------------------------
\section{Introduction}
%-------------------------------------------------------------------------------

A world where cloud compute is run in the format of serverless jobs is
attractive to developers and providers: developers pay only for what they use,
while having access to many resources when needed; and cloud providers have
control over scheduling and can use that to drive up utilization, rather than
needing to hold idle resources available for clients who reserved them.


However, there also remain some things that make serverless today fundamentally
infeasible for workloads that in theory are a good fit --- for instance web
servers, which are often bursty and have inconsistent load, but are rarely run
completely in lambda functions.\cite{TODO} One of the things that makes running
a web server on lambda infeasible is lambda invocations' variable end to end
latencies: in a small benchmark (broken down in Section~\ref{motivation}) we
found that end to end latencies for a simple hello world lambda function ranged
from AA to BB.


What developers care about in the end is that the jobs that are important run
quickly. We propose \sys{}, a scheduling system that has
\textit{\priceclass{}es} as the central metric associated with each job.
Priority and preemption in the system is directly paid for through these price
\class{}es, and all of the resource allocation decisions in \sys{} are made on
the basis of \class{}. 

\Sys{} has multiple goals and challenges that it needs to achieve in order to
move towards an environment where it is plausible to run web server page views
entirely as serverless jobs. 

One key goal is that \sys{} needs to be able to support a multi tenant
environment. This is enabled by the \priceclass{}es being a universal metric.
Rather than dealing in a relative ordering of developers' functions by
importance, which would be difficult to compare across developers, the
connection to money allows the \class{} to have meaning in an absolute as well
as a relative way. It also incentivizes usage of the lower \class{}es for jobs
that are less important, which can then be executed much more cheaply.


Another important goal is that of placing jobs quickly enough. For example, a
job that takes 20ms to run cannot spend 100ms in scheduler queues and waiting
for an execution environment before even starting to run. In a modern
datacenter, where both the number of new jobs coming in and the amount of
resources are extremely large, the challenge is knowing where the free and idle
resources are, or finding out quickly.


A key challenge in designing \sys{} is that of managing memory. For compute,
cores can always be timshared or processes preempted, but the buck stops once a
machine is out of memory. This problem is made more difficult by the fact that
\sys{} does not require memory usage limits to be given by developers, in an
effort to move away from the usual bin packing with overprovisioning problem,
and towards a more serverless on-demand approach also for memory.~\Sys{} is thus
faced with the challenging proposition of blindly placing jobs not knowing how
much memory they will use, but still needing memory utilization to be high.



 
