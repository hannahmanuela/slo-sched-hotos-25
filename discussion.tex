%-------------------------------------------------------------------------------
\section{Discussion}
%-------------------------------------------------------------------------------


There remain many interesting open questions in fully fleshing out this problem
and design. We discuss some of the questions that we expect will guide our
future research on this project; the first two are somewhat concrete technical
questions and the last one is more of a philosophical musing about the chosen
interface.


\textbf{Is swapping the right thing to be doing?}
In our design we use swapping, which works because of the assumption we make
about memory being large enough to for sure hold the memory of all the processes
that could fit on the cores. This assumption is likely true for the active
working sets of most jobs, but potentially not for their whole memory. If we
lift the assumption, then we are left with a potentially very undesirable
situation where less jobs than there are cores fit in the memory, and so they
are constantly being swapped in and out as the idle core wants to run the job
that was swapped out, and swaps out a job actually running somewhere else.

In order to avoid this situation, paging, or a combination of swapping and
paging, might be better. Some of the challenges in answering this question are
choosing what memory to page, and deciding how billing works for jobs who were
forced to page some of their memory. 

\textbf{Can we bound the amount of memory we need to swap/page?}
Given some swapping and/or paging scheme, there is a fundamental question of
whether we can bound the amount of memory that would need to be swapped/paged on
any machine. This is especially tricky in combination with the fact that we do
not have any sense of how much memory each job will use. One potential
assumption that would help here is to bound the maximum amount of memory that
any job can use; the bound could be very high, but doing so would allow us to
use queue length to also bound the amount of memory that the machine will need
to have (in both RAM and swapspace).


\textbf{How do developers know they not are getting cheated?}

In our scheme based on \priceclass{}es, there are no outwardly visible
guarantees in the same way that there are for resources (where running a short
benchmark will show exactly the amount of resources you have access to). There
are however many other ways that we already trust cloud providers without much
proof that we can verify ourselves, including that fundamentally providers could
always simply deny service and stop running anything. Of course providers have
market-based incentive to not provide lesser quality services for the same
price, and certainly a coordinated effort would quickly be able to reveal if
priority inversions were in fact going on.



